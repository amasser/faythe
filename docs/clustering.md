# Faythe cluster specs

Leverage Etcd to manage and keep cluster state.

1. We can leverage namespace mechanism to avoid corrupting between clusters. Users have to start a node with `--cluster-id` flag to join a existing cluster. If nothing was passed, a completely new cluster is initialized.

2. The member model stores with key `cluster/<id>` in Etcd (The `id` is generated by hasing a `name` and a `name` is the node's hostname).

```golang
type Member struct {
    ID      string      `json:"id"`
	Name    string      `json:"name"`
	Address net.IP      `json:"address"`
	Tags    []string    `json:"tags"`
}
```

3. Beside the Etcd cluster data, a node initializes a consistent hashring to hold the abstract nodes. Every nodes belong to cluster keeps watching on a `cluster/` key:
* Event `PUT` -> Init if not exist/Add node to hash ring.
* Event `DELETE` -> Remove node from hash ring.

5. Each node manages a subset of workers. To locate a worker, we can leverage consistent hashring.

6. When a node is joining a cluster, it puts a key-value pair with [lease](https://etcd.io/docs/v3.4.0/dev-guide/interacting_v3/#grant-leases). When a key is attached to a lease, its lifetime is bound to the leaseâ€™s lifetime which in turn is governed by a time-to-live (TTL). Periodically, node refreshs lease's TTL to keep it alive. Therefore, when a node goes down, a lease will expire and the attached key will be deleted. Other nodes that is watching for the `cluster/` key catches the DELETE event then update their hash ring and reload workers.
